"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const react_redux_1 = require("react-redux");
const constants_1 = require("../constants");
const reselect_1 = require("reselect");
const React = require("react");
const styles = require("../sub1/styles.scss");
const react_tippy_1 = require("react-tippy");
class Sub6 extends React.Component {
    constructor() {
        super();
        this.state = {};
    }
    render() {
        return (React.createElement("div", null,
            "Last, we need to set up the way the two solver couple with each other.",
            React.createElement("br", null),
            React.createElement("br", null),
            React.createElement("li", null,
                React.createElement("span", { className: styles.highlight }, "coupling-scheme"),
                ": Here we use ",
                React.createElement("span", { className: styles.highlight }, "serial-implicit"),
                ".",
                React.createElement(react_tippy_1.Tooltip, { trigger: "click", width: "100", interactive: true, html: (React.createElement("div", null,
                        React.createElement("span", { className: styles.highlight }, "serial"),
                        " refers to the fact that the two solvers operate serially with respect to each other - one waits for the other to finish its timestep.",
                        React.createElement("br", null),
                        "A ",
                        React.createElement("span", { className: styles.highlight }, "parallel"),
                        " coupling-scheme would allow simultaneous computation of both solvers.",
                        React.createElement("br", null),
                        React.createElement("span", { className: styles.highlight }, "implicit"),
                        " means that we sub-iterate between both solvers in every timestep until convergence.",
                        React.createElement("br", null),
                        "An ",
                        React.createElement("span", { className: styles.highlight }, "explicit"),
                        " scheme would let every solver only compute once and then already move on to the next timestep.")) },
                    React.createElement("span", { className: "fa fa-question-circle", style: { fontSize: '18px' } }),
                    "\u00A0")),
            React.createElement("li", null,
                React.createElement("span", { className: styles.highlight }, "first"),
                ": Name of the first participant(the one who leads the coupling)."),
            React.createElement("li", null,
                React.createElement("span", { className: styles.highlight }, "second"),
                ": Name of the second participant (the post-processing at the convergence measures are applied at the second participant)"),
            React.createElement("li", null,
                React.createElement("span", { className: styles.highlight }, "max-time value"),
                ": Total simulation runtime."),
            React.createElement("li", null,
                React.createElement("span", { className: styles.highlight }, "timestep-length value"),
                ": Length of the maximum allowed coupling timestep."),
            React.createElement("li", null,
                React.createElement("span", { className: styles.highlight }, "max-iterations value"),
                ": Maximum number of implicit sub-iterations."),
            React.createElement("br", null),
            React.createElement("li", null,
                React.createElement("span", { className: styles.highlight }, "exchange"),
                ": We also need to exchange data through this mesh between the two participants.",
                React.createElement(react_tippy_1.Tooltip, { trigger: "click", width: "100", interactive: true, html: (React.createElement("div", null,
                        "Recall that, in the participant ",
                        React.createElement("span", { className: styles.highlight }, "SU2_CFD"),
                        ", we had mapped ",
                        React.createElement("span", { className: styles.highlight }, "DisplacementDeltas0"),
                        " from and ",
                        React.createElement("span", { className: styles.highlight }, "Forces0"),
                        " to the mesh ",
                        React.createElement("span", { className: styles.highlight }, "Calculix_Mesh"),
                        ". Therefore we need data exchange. Please note that both participants must use this mesh with ",
                        React.createElement("span", { className: styles.highlight }, "use-mesh"),
                        ". Each dataset must be exchanged in the correct direction.")) },
                    React.createElement("span", { className: "fa fa-question-circle", style: { fontSize: '18px' } }),
                    "\u00A0")),
            React.createElement("li", null,
                React.createElement("span", { className: styles.highlight }, "data"),
                ": Dataset to be exchanged.."),
            React.createElement("li", null,
                React.createElement("span", { className: styles.highlight }, "mesh"),
                ": Name of the mesh through which data is exchanged."),
            React.createElement("li", null,
                React.createElement("span", { className: styles.highlight }, "from"),
                ": Source participant."),
            React.createElement("li", null,
                React.createElement("span", { className: styles.highlight }, "to"),
                ": Destination participant."),
            React.createElement("br", null),
            React.createElement("li", null,
                React.createElement("span", { className: styles.highlight }, "relative-convergence-measure"),
                ": We further set convergence measures for the data sets, after which the implicit sub-iterations will be stopped.",
                React.createElement(react_tippy_1.Tooltip, { trigger: "click", width: "100", interactive: true, html: (React.createElement("div", null,
                        React.createElement("span", { className: styles.highlight }, "relative-convergence-measure"),
                        " simply means that convergence is achieved if ",
                        React.createElement("span", { className: styles.highlight },
                            "|data - oldData|",
                            '<',
                            " limit * |data|"),
                        ", where all norms are L2 norms. The expression on the right-hand side is referred to as ",
                        React.createElement("span", { className: styles.highlight }, "relative limit"),
                        " in the preCICE logging output.")) },
                    React.createElement("span", { className: "fa fa-question-circle", style: { fontSize: '18px' } }),
                    "\u00A0")),
            React.createElement("li", null,
                React.createElement("span", { className: styles.highlight }, "data"),
                ": Dataset to be measured."),
            React.createElement("li", null,
                React.createElement("span", { className: styles.highlight }, "mesh"),
                ": Mesh holding the dataset data."),
            React.createElement("li", null,
                React.createElement("span", { className: styles.highlight }, "limit"),
                ": Convergence limit."),
            React.createElement("br", null),
            React.createElement("li", null,
                React.createElement("span", { className: styles.highlight }, "extrapolation-order value"),
                ": Specifies the number of previous timesteps from which the initial guess for the next timestep is constructed.",
                React.createElement(react_tippy_1.Tooltip, { trigger: "click", width: "100", interactive: true, html: (React.createElement("div", null,
                        "For example, if ",
                        React.createElement("span", { className: styles.highlight }, "value"),
                        " is 2, then a second-order extrapolation of the next timestep's initial guess is done from the current and the previous timestep results.")) },
                    React.createElement("span", { className: "fa fa-question-circle", style: { fontSize: '18px' } }),
                    "\u00A0")),
            React.createElement("br", null),
            React.createElement("li", null,
                React.createElement("span", { className: styles.highlight }, "post-processing"),
                ": Here, we use the ",
                React.createElement("span", { className: styles.highlight }, "aitken"),
                " scheme.",
                React.createElement(react_tippy_1.Tooltip, { trigger: "click", width: "100", interactive: true, html: (React.createElement("div", null,
                        "preCICE offers various methods for post-processing. For more methods, please refer to ",
                        React.createElement("a", { style: { color: 'white' }, href: "https://github.com/precice/precice/wiki/XML-Reference" }, "XML reference"),
                        ".")) },
                    React.createElement("span", { className: "fa fa-question-circle", style: { fontSize: '18px' } }),
                    "\u00A0")),
            React.createElement("li", null,
                React.createElement("span", { className: styles.highlight }, "data name"),
                ": Name of dataset to be post-processed."),
            React.createElement("li", null,
                React.createElement("span", { className: styles.highlight }, "mesh"),
                ": Mesh on which data is located."),
            React.createElement("li", null,
                React.createElement("span", { className: styles.highlight }, "initial-relaxation value"),
                ": value for first underrelaxation. 0.1 is a robust choice."),
            React.createElement("br", null)));
    }
}
const mapStateToProps = reselect_1.createStructuredSelector({});
function mapDispatchToProps(dispatch) {
    return {
        example: () => dispatch({ type: constants_1.EXAMPLE_ACTION }),
    };
}
exports.default = react_redux_1.connect(mapStateToProps, mapDispatchToProps)(Sub6);
//# sourceMappingURL=index.js.map